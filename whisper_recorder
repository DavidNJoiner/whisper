import whisper
import numpy as np
import pyaudio
import wave
import audioop
import datetime
import threading
import psutil
import os

# UI
import tkinter as tk
from tkinter import ttk
from tkinter import filedialog
from tkinter import messagebox


class AudioRecorder:
    def __init__(self, root):
        self.root = root
        self.root.title("Whisper Recorder")
        self.root.geometry("800x600")
        
        # Styling
        style = ttk.Style()
        style.configure('TButton', font=('Arial', 16), foreground='black')
        style.configure('TScale', font=('Arial', 16), foreground='black')
        style.configure('TMenubutton', font=('Arial', 16), foreground='black')
       

        self.filename = None
        self.transcript_file = 'transcript.txt'
        self.CHUNK = 1024
        self.FORMAT = pyaudio.paInt16
        self.CHANNELS = 1
        self.RATE = 44100
        self.SILENCE_THRESHOLD = 5000
        self.recording = False
        self.frames = []
        self.record_id = 0
        self.model = 'tiny'

        # Frame for the status bar
        status_frame = tk.Frame(root)
        status_frame.pack(side=tk.BOTTOM, fill=tk.X)

        # Status bar at the left side of the frame
        self.status_var = tk.StringVar()
        self.status_bar = tk.Label(status_frame, textvariable=self.status_var, bd=1, relief=tk.SUNKEN, anchor=tk.W)
        self.status_bar.pack(side=tk.LEFT, fill=tk.X)
        
        # Menubar
        menubar = tk.Menu(root)
        filemenu = tk.Menu(menubar, tearoff=0)
        filemenu.add_command(label="Upload Audio", command=self.upload_wav)
        devicemenu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="File", menu=filemenu)
        menubar.add_cascade(label="Devices", menu=devicemenu)
        root.config(menu=menubar)

        # Get available devices
        self.available_devices = self.get_available_devices()

        # Add each device to the menu
        default_device = self.available_devices[0] if self.available_devices else None
        for device in self.available_devices:
            devicemenu.add_command(label=device, command=lambda d=device: self.select_device(d))
        if default_device:
            self.select_device(default_device) 

        ## RAM Stuff 
        # RAM info at the right side of the frame
        self.ram_info_var = tk.StringVar()
        self.ram_info_bar = tk.Label(status_frame, textvariable=self.ram_info_var, bd=1, relief=tk.SUNKEN, anchor=tk.E)
        self.ram_info_bar.pack(side=tk.RIGHT, fill=tk.X)

        mem_info = psutil.virtual_memory()
        self.total = mem_info.total / (1024 ** 3)  
        self.available = mem_info.available / (1024 ** 3) 
        self.ram_info_var.set(f"RAM: {round(self.available, 1)} / {round(self.total, 1)}")

        ##  Model menu
        modelmenu = tk.Menu(menubar, tearoff=0)

        # Model options
        self.models = [
            {"name": "tiny", "ram": 1},
            {"name": "base", "ram": 1},
            {"name": "small", "ram": 2},
            {"name": "medium", "ram": 5},
            {"name": "large", "ram": 10},
        ]

        # Add each model to the menu
        default_model = self.models[0]  # Select 'tiny' model by default
        for model in self.models:
            state = "normal" if model["ram"] <= self.available/2 else "disabled"
            modelmenu.add_command(label=f"{model['name']} ({model['ram']}GB of VRAM required)", command=lambda m=model: self.select_model(m), state=state)
        self.select_model(default_model)  # Select the default model

        menubar.add_cascade(label="Model", menu=modelmenu)


        # Frame for buttons
        button_frame = ttk.Frame(root)
        button_frame.pack(side='top', fill='x', padx=5, pady=5)

        # Recording indicator
        self.recording_indicator = tk.Canvas(button_frame, width=30, height=30, bd=0, highlightthickness=0)
        self.recording_dot = self.recording_indicator.create_oval(5, 5, 25, 25, fill='gray')
        self.recording_indicator.pack(side='left', padx=5)

        # Record button
        self.record_button = ttk.Button(button_frame, text='record', command=self.toggle_recording)
        self.record_button.pack(side='left', padx=5)

        # Upload button
        self.upload_button = ttk.Button(button_frame, text='upload', command=self.upload_wav)
        self.upload_button.pack(side='right', padx=5)

        ## Silence threshold slider
        # Frame to hold slider_frame
        grid_frame = tk.Frame(root)
        grid_frame.pack(side='top', fill='x', padx=5, pady=5)

        # Slider frame
        slider_frame = ttk.Frame(grid_frame)
        slider_frame.grid(sticky='ew')

        # Make the column expand
        grid_frame.grid_columnconfigure(0, weight=1)

        self.silence_slider = ttk.Scale(slider_frame, from_=1000, to=5000, orient='horizontal', command=self.update_silence_threshold)
        self.silence_slider.grid(row=0, column=0, sticky='ew')  # This makes the slider expand within its cell

        # Make the slider's column expand
        slider_frame.grid_columnconfigure(0, weight=1)

        self.silence_slider.set(self.SILENCE_THRESHOLD)

        self.threshold_label = ttk.Label(slider_frame, text="Silence Threshold (ms): 5000")
        self.threshold_label.grid(row=0, column=1, padx=5)


        # Audio list
        self.audio_list = tk.Listbox(root, font=("Arial", 16), fg="white", selectbackground="green")
        self.audio_list.configure(background="#3d3d3d")
        self.audio_list.bind("<Button-3>", self.audio_list_popup)
        self.audio_list.pack(side='top', fill='both', expand=True, padx=5, pady=5)


        # Transcribe button
        self.transcribe_button = ttk.Button(root, text='Transcribe', command=self.transcribe_selected_audio)
        self.transcribe_button.pack(side='top', fill='x', padx=5, pady=5)

        self.update_audio_list()


    def get_available_devices(self):
        p = pyaudio.PyAudio()
        devices = []
        device_count = p.get_device_count()
        for i in range(device_count):
            device_info = p.get_device_info_by_index(i)
            devices.append(device_info["name"])
        p.terminate()
        return devices

    def select_device(self, device):
        self.update_status(f"Device switched to {device}")

    def select_model(self, model):
        self.model = model
        self.update_status(f"Model switched to {model['name']}")


    def update_status(self, status):
        self.status_var.set(status)

    def audio_list_popup(self, event):
        popup = tk.Menu(self.root, tearoff=0)
        popup.add_command(label="Transcribe", command=lambda: self.transcribe_selected_audio())
        popup.add_command(label="Delete", command=lambda: self.delete_selected_audio())
        popup.add_command(label="Rename", command=lambda: self.rename_selected_audio())
        try:
            popup.tk_popup(event.x_root, event.y_root)
        finally:
            popup.grab_release()

    def transcribe_selected_audio(self):
        selected_audio = self.audio_list.get(self.audio_list.curselection())
        if selected_audio:
            self.filename = selected_audio
            self.start_transcribing()
            self.update_status("Finished Transcribing")
        else:
            self.update_status("No audio file selected.")

    def delete_selected_audio(self):
        selected_audio = self.audio_list.get(self.audio_list.curselection())
        if selected_audio:
            os.remove(selected_audio)
            self.update_audio_list()
    
    def rename_selected_audio(self):
        selected_audio = self.audio_list.get(self.audio_list.curselection())
        if selected_audio:
            new_name = filedialog.asksaveasfilename(defaultextension=".wav")
            if new_name:
                os.rename(selected_audio, new_name)
                self.update_audio_list()

    def rename_selected_audio(self):
        selected_audio = self.audio_list.get(self.audio_list.curselection())
        if selected_audio:
            new_name = filedialog.asksaveasfilename(defaultextension=".wav")
            if new_name:
                os.rename(selected_audio, new_name)
                self.update_audio_list()

    def toggle_recording(self):
        if self.recording:
            self.recording_indicator.itemconfig(self.recording_dot, fill='gray')
            self.recording = False
            self.record_button.config(text='Record')
            self.save_audio()
            self.update_audio_list()
        else:
            self.filename = f'audio_{str(self.record_id).zfill(3)}.wav'
            self.record_id += 1
            self.recording_indicator.itemconfig(self.recording_dot, fill='green')
            self.recording = True
            self.record_button.config(text='Stop')
            threading.Thread(target=self.record_audio).start()

    def record_audio(self):
        p = pyaudio.PyAudio()

        stream = p.open(format=self.FORMAT,
                        channels=self.CHANNELS,
                        rate=self.RATE,
                        input=True,
                        frames_per_buffer=self.CHUNK)

        silent_frames = 0

        while self.recording:
            data = stream.read(self.CHUNK, exception_on_overflow=False)
            self.frames.append(data)

            if audioop.rms(data, 4) < self.SILENCE_THRESHOLD:
                silent_frames += 1

            if audioop.rms(data, 2) > self.SILENCE_THRESHOLD:
                silent_frames = 0

        stream.stop_stream()
        stream.close()
        p.terminate()

    def save_audio(self):
        p = pyaudio.PyAudio()
        wf = wave.open(self.filename, 'wb')
        wf.setnchannels(self.CHANNELS)
        wf.setsampwidth(p.get_sample_size(self.FORMAT))
        wf.setframerate(self.RATE)
        wf.writeframes(b''.join(self.frames))
        wf.close()
        self.frames = []

    def update_silence_threshold(self, value):
        self.SILENCE_THRESHOLD = int(float(value))
        self.threshold_label.config(text=f"Silence Threshold (ms): {int(float(value))}")


    def upload_wav(self):
        filename = filedialog.askopenfilename(filetypes=[('WAV Files', '*.wav')])
        if filename:
            self.filename = filename
            self.update_status(f"Uploaded {self.filename}")
            self.update_audio_list()


    def update_audio_list(self):
        self.audio_list.delete(0, 'end')
        for file in os.listdir("."):
            if file.endswith(".wav"):
                self.audio_list.insert('end', file)

    def start_transcribing(self):
        if self.filename:
            threading.Thread(target=self.transcribe_audio).start()

    def transcribe_audio(self):
        self.update_status("Transcribing...")
        try:
            model = whisper.load_model(self.model['name'])
        except Exception as e:
            self.update_status(f"Error loading model: {e}")
            return
        result = model.transcribe(self.filename)
        self.save_transcript(result)

    def save_transcript(self, transcript):
        audio_name, audio_ext = os.path.splitext(self.filename)
        transcript_filename = f"{audio_name}.txt"

        with open(transcript_filename, "w") as file:
            file.write(transcript["text"])
        self.update_status(f"Transcript saved as {transcript_filename} in the current directory.")

if __name__ == "__main__":
    root = tk.Tk()
    app = AudioRecorder(root)
    root.mainloop()